import {
  appendErrors,
  get
} from "./chunk-MIBJFQQJ.js";
import "./chunk-KZA2ZXKF.js";
import "./chunk-LNEMQRCO.js";

// node_modules/@hookform/resolvers/dist/resolvers.mjs
var t = function(t2, n2, e2) {
  if (t2 && "reportValidity" in t2) {
    var i2 = get(e2, n2);
    t2.setCustomValidity(i2 && i2.message || ""), t2.reportValidity();
  }
};
var n = function(r, n2) {
  var e2 = function(e3) {
    var i3 = n2.fields[e3];
    i3 && i3.ref && "reportValidity" in i3.ref ? t(i3.ref, e3, r) : i3.refs && i3.refs.forEach(function(n3) {
      return t(n3, e3, r);
    });
  };
  for (var i2 in n2.fields)
    e2(i2);
};
var e = function(r) {
  return r instanceof Date;
};
var i = function(r) {
  return null == r;
};
var a = function(r) {
  return "object" == typeof r;
};
var o = function(r) {
  return !i(r) && !Array.isArray(r) && a(r) && !e(r);
};
var f = function(r) {
  return /^\w*$/.test(r);
};
var s = function(r, t2, n2) {
  for (var e2 = -1, i2 = f(t2) ? [t2] : function(r2) {
    return t3 = r2.replace(/["|']|\]/g, "").split(/\.|\[/), Array.isArray(t3) ? t3.filter(Boolean) : [];
    var t3;
  }(t2), a2 = i2.length, s2 = a2 - 1; ++e2 < a2; ) {
    var u2 = i2[e2], c2 = n2;
    if (e2 !== s2) {
      var l = r[u2];
      c2 = o(l) || Array.isArray(l) ? l : isNaN(+i2[e2 + 1]) ? {} : [];
    }
    r[u2] = c2, r = r[u2];
  }
  return r;
};
var u = function(t2, e2) {
  e2.shouldUseNativeValidation && n(t2, e2);
  var i2 = {};
  for (var a2 in t2) {
    var o2 = get(e2.fields, a2), f2 = Object.assign(t2[a2] || {}, { ref: o2 && o2.ref });
    if (c(e2.names || Object.keys(t2), a2)) {
      var u2 = Object.assign({}, get(i2, a2));
      s(u2, "root", f2), s(i2, a2, u2);
    } else
      s(i2, a2, f2);
  }
  return i2;
};
var c = function(r, t2) {
  return r.some(function(r2) {
    return r2.startsWith(t2 + ".");
  });
};

// node_modules/@hookform/resolvers/yup/src/yup.ts
var parseErrorSchema = (error, validateAllFieldCriteria) => {
  return (error.inner || []).reduce(
    (previous, error2) => {
      if (!previous[error2.path]) {
        previous[error2.path] = { message: error2.message, type: error2.type };
      }
      if (validateAllFieldCriteria) {
        const types = previous[error2.path].types;
        const messages = types && types[error2.type];
        previous[error2.path] = appendErrors(
          error2.path,
          validateAllFieldCriteria,
          previous,
          error2.type,
          messages ? [].concat(messages, error2.message) : error2.message
        );
      }
      return previous;
    },
    {}
  );
};
function yupResolver(schema, schemaOptions = {}, resolverOptions = {}) {
  return async (values, context, options) => {
    try {
      if (schemaOptions.context && true) {
        console.warn(
          "You should not used the yup options context. Please, use the 'useForm' context object instead"
        );
      }
      const result = await schema[resolverOptions.mode === "sync" ? "validateSync" : "validate"](
        values,
        Object.assign({ abortEarly: false }, schemaOptions, { context })
      );
      options.shouldUseNativeValidation && n({}, options);
      return {
        values: resolverOptions.raw ? values : result,
        errors: {}
      };
    } catch (e2) {
      if (!e2.inner) {
        throw e2;
      }
      return {
        values: {},
        errors: u(
          parseErrorSchema(
            e2,
            !options.shouldUseNativeValidation && options.criteriaMode === "all"
          ),
          options
        )
      };
    }
  };
}
export {
  yupResolver
};
//# sourceMappingURL=@hookform_resolvers_yup_src_yup__js.js.map
